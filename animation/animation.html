<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Smooth Text Highlighter</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      min-height: 300vh;
      position: relative;
      color: #333;
      line-height: 1.6;
    }
    header {
      height: 80px;
      border-bottom: 1px solid #eee;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: #fafafa;
    }
    header h1 {
      margin: 0;
      font-weight: 500;
      color: #333;
    }
    .section-block {
      position: relative;
      width: 100%;
      height: 100vh;
      padding: 3rem;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }
    .section-title {
      font-size: 2.2rem;
      margin-bottom: 1.5rem;
      font-weight: 500;
    }
    .section-content {
      max-width: 800px;
      margin: 0 auto;
    }
    p {
      font-size: 1.1rem;
      margin-bottom: 1.5rem;
      line-height: 1.7;
    }
    .highlight-row {
      display: flex;
      height: 40px;
      margin: 2rem 0;
      position: relative;
    }
    .highlight-square {
      position: absolute;
      width: 40px;
      height: 40px;
      background-color: rgba(255, 255, 255, 0.9);
      border: 2px solid #3498db;
      border-radius: 5px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      /* Updated transition to match JS timing (0.24s, not 0.4s) */
      transition: all 0.24s cubic-bezier(0.22, 1, 0.36, 1);
    }
    .highlight-text {
      font-weight: 500;
      color: #3498db;
      margin-top: 1rem;
    }
    .dark-mode {
      background-color: #222;
      color: #f5f5f5;
    }
    .dark-mode header {
      background-color: #333;
      border-bottom: 1px solid #444;
    }
    .dark-mode header h1,
    .dark-mode .section-title {
      color: #f5f5f5;
    }
    .dark-mode .highlight-square {
      background-color: rgba(40, 40, 40, 0.9);
      border: 2px solid #3498db;
    }
    .toggle-theme {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 100;
      padding: 8px 16px;
      background-color: #3498db;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }
  </style>
</head>
<body>

  <header>
    <h1>Smooth Text Highlighter</h1>
  </header>

  <button class="toggle-theme" onclick="toggleTheme()">Toggle Dark Mode</button>

  <section class="section-block" id="section1">
    <div class="section-content">
      <h2 class="section-title">Introduction</h2>
      <p>Welcome to our interactive text highlighter demonstration. This tool uses smooth animations to help draw attention to content in the next section of your page.</p>
      <p>As you scroll down, watch how the highlight squares smoothly transition between sections, elegantly guiding the reader's attention to what comes next.</p>
      <div class="highlight-row" id="row1"></div>
      <p class="highlight-text">Scroll down to see the next section</p>
    </div>
  </section>

  <section class="section-block" id="section2">
    <div class="section-content">
      <h2 class="section-title">Key Features</h2>
      <p>The highlight squares create a visual pathway that guides the user from one section to the next, improving navigation and user experience.</p>
      <p>This animation technique creates a sense of continuity between page sections, making the scrolling experience more engaging and intuitive.</p>
      <div class="highlight-row" id="row2"></div>
      <p class="highlight-text">Continue scrolling for implementation details</p>
    </div>
  </section>

  <section class="section-block" id="section3">
    <div class="section-content">
      <h2 class="section-title">Implementation</h2>
      <p>This highlighting system uses the Intersection Observer API to detect when sections enter the viewport. The transition animations are handled with CSS, making them smooth and performance-friendly.</p>
      <p>The squares follow a snake-like pattern, creating a visually pleasing effect that draws the eye through your content in a natural way.</p>
      <div class="highlight-row" id="row3"></div>
    </div>
  </section>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      /*********************************************************
       * 1) Create highlight squares and calculate positions
       *********************************************************/
      const SQUARE_COUNT = 4;
      const squareSize = 40;
      const gap = 15;
      const squares = [];

      // Get all the row containers
      const rows = document.querySelectorAll('.highlight-row');

      // Calculate total width needed for all squares
      const totalWidth = SQUARE_COUNT * (squareSize + gap) - gap;

      // Center the squares in the row
      let startX = (window.innerWidth - totalWidth) / 2;

      for (let i = 0; i < SQUARE_COUNT; i++) {
        const sq = document.createElement("div");
        sq.classList.add("highlight-square");
        sq.id = `square-${i}`;

        // Calculate horizontal position
        const leftPos = startX + i * (squareSize + gap);

        // Position square in the first row (temporary, will be updated later)
        sq.style.left = leftPos + "px";
        sq.style.top = "0px";

        document.body.appendChild(sq);
        squares.push(sq);
      }

      /*********************************************************
       * 2) IntersectionObserver for each section
       *********************************************************/
      const sections = document.querySelectorAll(".section-block");
      let currentSectionIndex = 0;
      let isAnimating = false;

      const observerOptions = {
        root: null,
        threshold: 0.6, // Higher threshold for more precise triggering
      };

      const sectionObserver = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (isAnimating) return;
          const sectionIndex = Array.from(sections).indexOf(entry.target);
          if (entry.isIntersecting) {
            if (sectionIndex > currentSectionIndex) {
              isAnimating = true;
              snakeDown(currentSectionIndex, sectionIndex)
                .then(() => {
                  currentSectionIndex = sectionIndex;
                  isAnimating = false;
                });
            } else if (sectionIndex < currentSectionIndex) {
              isAnimating = true;
              snakeUp(currentSectionIndex, sectionIndex)
                .then(() => {
                  currentSectionIndex = sectionIndex;
                  isAnimating = false;
                });
            }
          }
        });
      }, observerOptions);

      sections.forEach((sec) => {
        sectionObserver.observe(sec);
      });

      /*********************************************************
       * 3) Generate snake path points between two sections
       *********************************************************/
      function generateSnakePath(fromSection, toSection) {
        const fromRect = rows[fromSection].getBoundingClientRect();
        const toRect = rows[toSection].getBoundingClientRect();

        const fromTop = window.scrollY + fromRect.top;
        const toTop = window.scrollY + toRect.top;

        // Calculate positions
        const topRowY = fromTop;
        const bottomRowY = toTop;

        // Calculate middle position for vertical movement
        const verticalDistance = bottomRowY - topRowY;
        const middleY1 = topRowY + verticalDistance / 2;

        // Define paths for each square (snakeDown)
        const paths = [];

        // Square 0 (head)
        paths.push([
          { x: startX, y: topRowY },                           
          { x: startX, y: middleY1 },                          
          { x: startX, y: bottomRowY },                        
          { x: startX + 3 * (squareSize + gap), y: bottomRowY }
        ]);

        // Square 1
        paths.push([
          { x: startX + (squareSize + gap), y: topRowY },      
          { x: startX, y: topRowY },                           
          { x: startX, y: middleY1 },                          
          { x: startX, y: bottomRowY },                        
          { x: startX + 2 * (squareSize + gap), y: bottomRowY }
        ]);

        // Square 2
        paths.push([
          { x: startX + 2 * (squareSize + gap), y: topRowY },  
          { x: startX + (squareSize + gap), y: topRowY },      
          { x: startX, y: topRowY },                           
          { x: startX, y: middleY1 },                          
          { x: startX, y: bottomRowY },                        
          { x: startX + (squareSize + gap), y: bottomRowY }    
        ]);

        // Square 3 (tail)
        paths.push([
          { x: startX + 3 * (squareSize + gap), y: topRowY },  
          { x: startX + 2 * (squareSize + gap), y: topRowY },  
          { x: startX + (squareSize + gap), y: topRowY },      
          { x: startX, y: topRowY },                           
          { x: startX, y: middleY1 },                          
          { x: startX, y: bottomRowY },                        
          { x: startX, y: bottomRowY }                         
        ]);

        return paths;
      }

      /*********************************************************
       * 4) Snake Down Animation
       *********************************************************/
      async function snakeDown(fromSection, toSection) {
        const paths = generateSnakePath(fromSection, toSection);
        const movePromises = [];
        const sequenceDelay = 180; // ms
        const moveDelay = 240;     // ms (matching .24s transition)

        for (let i = 0; i < squares.length; i++) {
          const square = squares[i];
          const path = paths[i];
          const promise = new Promise(resolve => {
            let pointIndex = 0;
            function traversePath() {
              if (pointIndex >= path.length) {
                resolve();
                return;
              }
              const point = path[pointIndex];
              square.style.left = `${point.x}px`;
              square.style.top = `${point.y}px`;
              pointIndex++;
              setTimeout(traversePath, moveDelay);
            }
            setTimeout(traversePath, i * sequenceDelay);
          });
          movePromises.push(promise);
        }
        return Promise.all(movePromises);
      }

      /*********************************************************
       * 5) Snake Up Animation (Symmetrically matched with Down)
       *********************************************************/
      async function snakeUp(fromSection, toSection) {
        // Generate reverse paths for the upward movement
        const paths = [];
        
        // Need to create symmetrical paths for the upward movement
        // These should have the same number of steps as the downward paths
        
        const fromRect = rows[fromSection].getBoundingClientRect();
        const toRect = rows[toSection].getBoundingClientRect();

        const fromTop = window.scrollY + fromRect.top; // Bottom row
        const toTop = window.scrollY + toRect.top;    // Top row
        
        // Calculate positions
        const bottomRowY = fromTop;
        const topRowY = toTop;
        
        // Calculate middle position for vertical movement (same formula as in generateSnakePath)
        const verticalDistance = bottomRowY - topRowY;
        const middleY1 = topRowY + verticalDistance / 2;
        
        // Define symmetrical paths for upward movement
        // Square 3 (now the head for upward movement)
        paths.push([
          { x: startX + 3 * (squareSize + gap), y: bottomRowY }, // Start at bottom right
          { x: startX, y: bottomRowY },                         // Move to bottom left
          { x: startX, y: middleY1 },                           // Move to middle
          { x: startX, y: topRowY },                            // Move to top left
          { x: startX + 3 * (squareSize + gap), y: topRowY }    // Move to top right (final)
        ]);
        
        // Square 2
        paths.push([
          { x: startX + 2 * (squareSize + gap), y: bottomRowY }, // Start at bottom
          { x: startX + 3 * (squareSize + gap), y: bottomRowY }, // Move to bottom right
          { x: startX, y: bottomRowY },                         // Move to bottom left
          { x: startX, y: middleY1 },                           // Move to middle
          { x: startX, y: topRowY },                            // Move to top left
          { x: startX + 2 * (squareSize + gap), y: topRowY }    // Move to final position (top)
        ]);
        
        // Square 1
        paths.push([
          { x: startX + (squareSize + gap), y: bottomRowY },     // Start at bottom
          { x: startX + 2 * (squareSize + gap), y: bottomRowY }, // Move right
          { x: startX + 3 * (squareSize + gap), y: bottomRowY }, // Move right
          { x: startX, y: bottomRowY },                         // Move to left
          { x: startX, y: middleY1 },                           // Move to middle
          { x: startX, y: topRowY },                            // Move to top left
          { x: startX + (squareSize + gap), y: topRowY }        // Move to final position (top)
        ]);
        
        // Square 0
        paths.push([
          { x: startX, y: bottomRowY },                         // Start at bottom left
          { x: startX + (squareSize + gap), y: bottomRowY },     // Move right
          { x: startX + 2 * (squareSize + gap), y: bottomRowY }, // Move right
          { x: startX + 3 * (squareSize + gap), y: bottomRowY }, // Move right
          { x: startX, y: bottomRowY },                         // Move to left
          { x: startX, y: middleY1 },                           // Move to middle
          { x: startX, y: topRowY },                            // Move to final position (top)
        ]);
        
        const movePromises = [];
        const sequenceDelay = 180; // ms - same as snakeDown
        const moveDelay = 240;     // ms - same as snakeDown
        
        // Animate in reverse order (square-3 first, then square-2, etc.)
        for (let i = squares.length - 1; i >= 0; i--) {
          const square = squares[i];
          const path = paths[squares.length - 1 - i]; // Match path to correct square
          
          // Use the equivalent square's timing from snakeDown
          const downwardEquivalent = squares.length - 1 - i;
          
          const promise = new Promise(resolve => {
            let pointIndex = 0;
            
            function traversePath() {
              if (pointIndex >= path.length) {
                resolve();
                return;
              }
              
              const point = path[pointIndex];
              square.style.left = `${point.x}px`;
              square.style.top = `${point.y}px`;
              pointIndex++;
              
              setTimeout(traversePath, moveDelay);
            }
            
            // Use the equivalent square's initial delay from snakeDown
            const initialDelay = downwardEquivalent * sequenceDelay;
            setTimeout(traversePath, initialDelay);
          });
          
          movePromises.push(promise);
        }
        
        return Promise.all(movePromises);
      }

      // Initialize squares in the first section
      setTimeout(() => {
        const firstRowRect = rows[0].getBoundingClientRect();
        const firstRowTop = window.scrollY + firstRowRect.top;
        squares.forEach((square, i) => {
          const leftPos = startX + i * (squareSize + gap);
          square.style.left = `${leftPos}px`;
          square.style.top = `${firstRowTop}px`;
        });
      }, 100);

      // Update positions on resize
      window.addEventListener('resize', () => {
        const rowRect = rows[currentSectionIndex].getBoundingClientRect();
        const rowTop = window.scrollY + rowRect.top;
        startX = (window.innerWidth - (SQUARE_COUNT * (squareSize + gap) - gap)) / 2;
        if (isAnimating) return;
        squares.forEach((square, i) => {
          const newLeft = startX + i * (squareSize + gap);
          square.style.left = `${newLeft}px`;
          square.style.top = `${rowTop}px`;
        });
      });
    });

    // Toggle dark/light theme
    function toggleTheme() {
      document.body.classList.toggle('dark-mode');
    }
  </script>
</body>
</html>